

[TOC]



# JAVA中的锁

- JVM级别的锁Synchronized、lock
- 分布式锁ReRdis、ZK



## 1.JVM级别的锁

![](https://gitee.com/domineering_red_tide/image/raw/master/image/20210614083133.png)



- 乐观锁：CAS ⽐较并交换 。可以同时进行读操作，读的时候其他线程不能进行写操作 。乐观锁底层实现是CAS。原子类的底层实现都是CAS、自旋锁（while循环）。**适用于读多写少**。
- 悲观锁：只能有一个线程进行读操作或者写操作，其他线程的读写操作均不能进行。**适用于写多读少**。
- 自旋锁：CAS操作中的比较操作失败后的自旋等待。 避免了线程切换的开销。 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。
- 读写锁：读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥 
- 公平锁和非公平锁：synchronized是非公平锁，ReentrantLock通过构造函数指定该锁是公平的还是非公平的，默认是非公平的 



 lock和Synchronized区别：

-  Lock 是一个接口，而 synchronized 是 Java 中的关键字， synchronized 是内置的语言实现。 
-  synchronized会自动释放锁，而Lock必须手动释放锁 
-  Lock 可以通过实现读写锁提高多个线程进行读操作的效率 
-  Synchronized 是非公平锁，Lock 可以实现公平锁



悲观锁和乐观锁

悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁

乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据     



资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源

CAS (ompare and swap)：比较并交换（通过版本号解决ABA问题）

原子类的底层用了CAS（compareAndSet：比较并交换）（用了自旋锁）

乐观锁是CAS的实现



锁升级：Synchronized 在1.6 之前只是重量级锁，之后进行优化有个锁升级的过程。锁升级不可逆。

- 无锁
- 偏向锁：同一个线程一直拿锁，就不再锁竞争（ 偏向锁在1.6之后是默认开启的 ）
- 轻量级锁：其他线程竞争锁，经升级轻量级锁，自旋锁获取到锁（注：CAS）
- 重量级锁：10次自旋未拿到锁，升级为重量级锁
![](https://gitee.com/domineering_red_tide/image/raw/master/image/20210614085834.png)





## 2.分布式锁

Redis：使用SETNX+lua脚本  或者 Redisson工具

ZK：使用有序临时节点公平锁（最小节点拿到锁）；使用临时节点非公平锁（羊群效应）

