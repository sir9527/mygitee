[TOC]



# JAVA基础

## 1.JAVA数据类型

数据类型：**基本数据类型** 和 **引用数据类型**

- 基本数据类型

         整数    ：byte（1）          short（2）                 int （默认 4）                long（8）
    
                        进制：二进制（0b）、八进制（0）、十六进制（0x）
    
         浮点数：float（4）          double（默认 8）      BigDecimal
    
         字符    ：char（2）          
    
                        编码格式：        ascii                           utf-8                               unicode
    
                        转义字符：        \n    \r   \t   \\  等
    
         布尔值：boolean（1位）

- 引用数据类型：类  、 接口  、 数组



## 2.方法重写和方法重载

- 方法重写：子类重写父类方法
- 方法重载：名字相同，参数列表必须不同、返回类型可以相同可以不同





## 3. equals和==

- ==是运算符，equal是方法

- 重写equals，==比较的是内存地址，equal比较的是值

```

1.区别
==和equals最大的区别是一个是运算符一个是方法。在Java中，两者比较的都是物理地址，而不是值的比较。
调用的是Object类的equals方法。（并没有对其进行重写）

2.String
对于String类型来说。String类重写了equals方法
equals方法比较的是两个字符串的值是否一样。（不比较物理地址）。
所有的字符串都是String对象。由于字符串的大量使用，java中为了节省时间，在编译阶段，会把字符串文字放在字符串常量池中。

```





## 4.封装、继承、多态

- 封装：封装属性和方法 使用set和get
- 继承：子类继承父类 重写父类方法。static、final、private修饰的方法不能继承，所以也没有多态
- 多态：父类调用子类重写的方法。多态的条件：1.继承关系；2.子类重写父类方法；3.父类引用子类对象





## 5.抽象类和接口

继承抽象类可以提高代码复用性；实现多接口可以提高代码健壮性





## 6.JAVA异常体系

- 1.异常：程序本身可以捕获并且可以处理的异常。

  - 1.运行时异常(不受检异常)： JVM 在运行期间可能出现的错误。例如：空指针，数组越界...

  - 2.编译异常(受检异常)：必须使用系统提供的异常类对该异常进行处理，否则编译不通过。例如：IOException

- 2.错误：程序本身不能捕获的
     错误：代码运行时 JVM 出现问题。例如：虚拟机运行错误，类定义错误，内存溢出...



## 7.Hashtable、Hashmap和ConcurrentHashMap 

Hashtable

- 数组 + 链表    
- 线程安全 synchronized（sɪŋ krən aɪzd）

HashMap

- 1.8 "数组 + 链表 + 红黑树" （用key做的hash）
- 初始容量是16；加载因子0.75
- 线程不安全

ConcurrentHashMap（kən  ˈkʌ  rənt）

- 1.8 "数组+链表+红黑树"  

- 线程安全  synchronized（1.6 锁升级） 和 CAS 

- CAS + synchronized （CAS方式确定key的数组下标，synchronized保证链表节点的同步效果）

  



## 8.ThreadLocal线程隔离

当前线程和一个ThreadLocalMap绑定

ThreadLocalMap：使用ThreadLocal的实例对象弱引用作为Key，value为用户的值





## 9.JAVA的4种引用类型

注：对象都在堆中，引用在栈中

```java
强引用，软引用，弱引用，虚引用
1.强引用（StrongReference）
  如果一个对象具有强引用，垃圾回收器不会回收该对象；
  当内存空间不足时，JVM 宁愿抛出 OutOfMemoryError异常；
  只有当这个对象没有被引用时，才有可能会被回收。
2.软引用（SoftReference）
  当内存空间足够，垃圾回收器就不会回收它；
  当内存空间不足了，就会回收该对象；
  如果回收完还没有足够的内存，才会抛出内存溢出异常
  注：软引用是用来描述一些有用但并不是必需的对象，适合用来实现缓存
3.弱引用（WeakReference）
  当垃圾回收器扫描到只具有弱引用的对象时，无论当前内存空间是否足够，都会回收它。
4.虚引用（PhantomReference）
  如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收
```
