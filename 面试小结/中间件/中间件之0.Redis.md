





[TOC]



## 0.本地缓存和分布式缓存

1.本地缓存echache：直接在jvm虚拟机中缓存，速度快，效率高

2.分布式缓存redis

注： 本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中 



## 1.Redis常用的数据结构

```

1.String  key-value类型
2.List    底层时双端链表(注：java中的ArrayList底层是数组)
3.Set     不重复集合
4.ZSet    有序不重复集合
5.Hash    key-map(key-value)

```



**Sting数据结构底层用的是自定义数据结构SDS**

- `int`：当存储的字符串全是数字时，此时使用`int`方式来存储；
- `embstr`：当存储的字符串长度小于44个字符时，此时使用`embstr`方式来存储；
- `raw`：当存储的字符串长度大于44个字符时，此时使用`raw`方式来存储；





## 2.Redis分布式锁

SETNX是set If not exist的简写。意思就是当 key 不存在时，设置 key 的值，存在时，什么都不做

redisson：看门狗机制。如果不设置过期时间会10s检查过期时间会续到30s



## 3.Redis数据持久化

### 3.1 RDB（ Redis DB）

- fork是指redis通过创建子进程来进行RDB操作 
- 写时复制



时点性：保存的是**某一时刻**的 Redis 内存状态 



**写时复制技术**

linux 采用了写时复制技术，在 fork 出子进程时（进程间内存隔离）并没有立刻将内存进行拷贝，仅仅是拷贝了一份映射关系，让它们暂时指向同一个内存空间。  而当父子进程对这块内存空间进行写操作时，才会真正复制内存，而且是以页为单位。

这样既保证了时点性；也保证了效率，减少客户端阻塞时间（可以利用操作系统的进程的写时复制内存的原理，来代替我自己复制全部内存这个方案）。

![](https://gitee.com/domineering_red_tide/image/raw/master/image/20210606094327.png)



````

RDB持久化配置
Redis会将数据集的快照dump到dump.rdb文件中。
save 900 1           # 在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。
save 300 10          # 在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。
save 60 10000        # 在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。
注：save m n    表示m秒内数据集存在n次修改时，自动触发一次持久化

````



### 3.2 AOF

RDB持久化（默认使用）：指定的时间间隔内将内存中的数据集快照写入磁盘，即快照

AOF持久化：以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件



````

AOF持久化配置
在Redis的配置文件中存在三种同步方式，它们分别是：
appendfsync always     # 每次有数据修改发生时都会写入AOF文件。
appendfsync everysec   # 每秒钟同步一次，该策略为AOF的缺省策略。
appendfsync no         # 从不同步。高效但是数据不会被持久化。

````





### 3.3 RDB和AOF区别

- **RDB**都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。**AOF**则最多丢一秒的数据，**数据完整性**上高下立判 

-  一样的数据，**AOF**文件比**RDB**还要大 

-  两种机制全部开启的时候，Redis在重启的时候会默认使用**AOF**去重新构建数据，因为AOF的数据是比RDB更完整的





## 4.雪崩，击穿，穿透

雪崩：**同一时间大面积失效，那一瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的** 

解决： 在批量往**Redis**存数据的时候，把每个Key的失效时间都加个随机值就好了 



击穿：这个跟**缓存雪崩**有点像 ，不一样的地方是一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库 

解决：设置热点数据永远不过期 ； 或者加上互斥锁就能搞定了 



穿透： 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，攻击会导致数据库压力过大，严重会击垮数据库 

1.在接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return 
2.从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应Key的Value对写为null、位置错误、稍后重试这样的值，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用） 
3.布隆过滤器（Redis可以实现）这个也能很好的防止缓存穿透的发生。提前判断是否是数据库中存在的数据，若不在则拦截，直接return,存在则查DB再更新缓存。 







## 5.Redis为什么这么快

- 内存操作
- 单线程没有上下文切换
- IO多路复用：一个线程处理了多个客户端连接





## 6.Redis过期策略

 **Redis**的过期策略，是有**定期删除+惰性删除**两种 

 定期删除：默认100ms就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了 

 惰性删除：我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。 



内存满了就用内存淘汰策略，Redis提供8种，配置种默认使用"no-eviction"默认使用，而我们最常用的是配置成"allkeys-lru"。

**FIFO** 淘汰最早数据、**LRU** 剔除最近最少使用、和 **LFU** 剔除最近使用频率最低的数据 

![](https://gitee.com/domineering_red_tide/image/raw/master/image/20210612094116.png)






## 7.Redis线程模型

Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。



 这种一个负责响应 IO 事件（Redis使用IO 多路复用），一个负责交给相应的事件处理器去处理（Redis里叫事件处理器），就叫做 **Reactor模式**。 



**事件处理器**

- **连接应答处理器**，就是刚刚监听连接的文件描述符所绑定的函数 acceptHandler。

- **命令请求处理器**，就是监听客户端命令（读事件）的文件描述符绑定的函数 readQueryFromClient。

- **命令回复处理器**，就是后面要提到的，监听客户端响应（写事件）的文件描述符绑定的函数 sendReplyToClient。 **sendReplyToClient** 函数挂在需要响应的客户端连接的文件描述符上回复

![](https://gitee.com/domineering_red_tide/image/raw/master/image/20210612114910.png)





![](https://gitee.com/domineering_red_tide/image/raw/master/image/20210612120106.png)



## 8.Redis集群

**Redis的哨兵集群模式**

![](https://gitee.com/domineering_red_tide/image/raw/master/image/20210604154014.png)





**哨兵处理主节点故障**

1.监听主节点是否挂掉，如果挂掉则进行以下步骤

2.选择一个从节点，将其变为主节点。

规则：不选断线或下线的从节点； 选复制偏移量的值大的（同步数据多）；最后选唯一标识uid小的

3.修改其他从节点的附属主节点

4.将挂掉的主节点变为从节点



**哨兵集群**

1.一定数量哨兵认为主节点挂掉的才会进行故障处理

2.哨兵集群通过Raft算法决定哪台哨兵去处理故障



**Raft算法**

1.哨兵节点的3种状态：leader领导者  follower 跟随者  candidate 候选人
2.每段时间都会选一个leader领导者，其他为跟随者
3.领导者对外处理工作，然后同步数据给跟随者保持各个节点数据一致

注：raft是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议