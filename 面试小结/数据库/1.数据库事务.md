

## 1.数据库事务

```markdown
# 1.事务（要么都成功，要么都失败。例：转账）
增删改必须有事务，查询可以没有事务
事务原则：ACID --> 原子性、一致性、隔离性、持久性  （出现的问题：脏读、幻读、不可重复读）
1.1 原子性：转账和收账不可分隔。要么全成功，要么全失败
1.2 一致性：最终一致性（事务完成后，需要符合逻辑运算，总数不变）。
          事务都是原子性，也会出现数据不一致问题。需要隔离事务来保证数据一致性问题。
1.3 隔离性：事务隔离。转账和收账互不影响（4个隔离级别）。多个进程互不干扰。
1.4 持久性：事务没提交（恢复原状）、事务已经提交（持久化到数据库）。一旦提交不可逆


# 2.隔离级别（隔离性解决脏读、幻读、不可重复读）：
2.1 read uncommitted  未提交读
    事务中的修改，即使没有提交，其他事务也可以看得到 
    问题：脏读、不可重复读、幻读
2.2 read committed  提交读
    一个事务不会读到另一个并行事务已修改但未提交的数据（脏读）
    解决：脏读
    问题：不可重复读、幻读    
    Oracle数据库默认隔离级别
2.3.repeatable read  可重复读
    一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据 （不可重复读）
    解决：脏读、不可重复读
    问题：不可重复读 
    MySQL数据库默认隔离级别 
2.4.serializable 串行化
    当一个事物没有结束 另一个事务不允许开启 另一个事务在等候 
    解决：脏读、不可重复读、幻读 


# 3.没有隔离级别会产生的3个问题
- 脏读：一个事务读取了另一个事务未提交的数据（针对其他事务更新操作）
- 不可重复读：一个事务内读取表同一行数据，多次结果不同（针对其他事务更新操作）   
- 幻读：一个事务内读到了别的事务插入的数据，导致前后读取不一致（针对其他事务新增）  
注：不可重复读和幻读都是读取别的事务已提交数据；不可重复读针对更新，幻读针对新增和删除。

不可重复读：务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，
          而事务A再次读取该数据时，数据已经发生了改变。造成了不可重复读（虚读）
幻读：事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。
     事务A再读取时，却发现数据发生了变化。造成了幻读。      
        
```



![](https://gitee.com/domineering_red_tide/image/raw/master/image/20210609152727.png)



```markdown
     
# 4.MySql是如何解决幻读的？
    理论上RR（重复读）存在幻读，但是在MySQL的实现中，解决了幻读的问题了
    mysql innodb引擎默认是RR（重复读）的隔离级别
    
    在mysql中通过多版本并发控制MVCC快照读（一致性读） 
    和 
    next-key(当前读)（行记录锁+Gap间隙锁）两种模式解决幻读问题
    
    读-读：不存在任何问题，也不需要并发控制；读写和写写有线程安全问题
    MVCC快照读（读写操作没有冲突）：
    mvcc(版本号控制)的优势是不加锁，并发性高。缺点是不是实时数据。
    MVCC只在可重读和提交读两种隔离级别下工作
        1.select ... from table
        注：根据select快照数据进行操作（增删改会打破快照）
      
    当前读(next-key：record locks+gap locks)
    间隙锁和行锁合称NextKeyLock
    next-key的优势是获取实时数据，但是需要加锁。
    next-key(当前读)：记录锁（加在索引上的锁）+ 间隙锁（加载索引之间的锁）
        1.select ... lock in share mode  共享锁 
        2.select ... for update          排它锁
        3.insert、update、delete

MySQL InnDB 默认为RR级别，但是不会出现幻读

当事务A更新了所有记录的某个字段，此时事务A会获得对这个表的表锁，因为事务A还没有提交，所以事务A获得的锁没有释放，此时事务B在该表插入新记录，会因为无法获得该表的锁，则导致插入操作被阻塞。只有事务A提交了事务后，释放了锁，事务B才能进行接下去的操作。所以可以说   MySQL的RR级别的隔离是已经实现解决了脏读，不可重复读和幻读的。


MVCC + 悲观锁：MVCC解决读写冲突，悲观锁解决写写冲突
MVCC + 乐观锁：MVCC解决读写冲突，乐观锁解决写写冲突

```