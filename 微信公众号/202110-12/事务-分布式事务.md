

[TOC]



# 写在前面的话

```
这里从事务的ACID开始，向大家先说了XA是分布式事务处理的规范，之后谈到2PC和3PC。
2PC有同步阻塞、单点故障和数据不一致的问题；
3PC在一定程度上解决了同步阻塞和单点故障的问题，但是还是没有完全解决数据不一致的问题。


之后说到TCC、SAGA、消息队列的最终一致性的方案。
TCC由于实现过于麻烦和复杂，业务很少应用；
SAGA了解即可，国内也很少有应用到的；
消息队列提供了解耦的实现方式，对于中小公司来说可能是较为低成本的实现方式。


最后再说目前国内的实现框架。
云端阿里云的GTS兼容Seata，非云端使用Seata，它提供了XA、TCC、AT、SAGA的解决方案，可以说是目前的主流选择。
```



```
分布式事务，只是适用于面试和理论的了解，你真要说这些方案实际生产中有人用吗？
有，但是会实现的更简单，不会套用理论来实现，大厂有大厂的解决方案，中小公司用框架或者压根就不存在分布式事务的问题


对于TCC（这里说的不是框架实现的，是自己实现）来说，实际生产我基本上就没看见过有人用。
虑到原因，首先是程序员的本身素质参差不齐，多个团队协作你很难去约束别人按照你的规则来实现，另外一点就是太过于复杂。
```


## 1.分布式事务出现场景：

```
    1.数据库分库
    
    2.微服务调用
```


## 2.分布式事务的实现方式：XA、2PC、3PC、TCC、Seata

```
    分类：
        强一致性：2PC
        
        弱一致性：TCC  , MQ
```


```
    1.规范性东西：XA
    
    2.XA的具体实现：2PC、3PC
    
    3.2PC的变种：TCC
    
    4.分布式事务框架：Seata（阿里开源）， GTS(阿里付费)
    
    注：
        追求强一致性的两阶段提交；
        追求最终一致性的柔性事务（SAGA和TCC）和事务消息（MQ）
        
        扣钱-->强一致性  ；  订单 --> 弱一致性，柔性
```

### 我们综合对比下几种分布式事务解决方案
```
    1.一致性保证：XA > TCC = SAGA > 事务消息
    2.业务友好性：XA > 事务消息 > SAGA > TCC
    3.性 能 损 耗：XA > TCC > SAGA = 事务消息
    
    注：在柔性事务解决方案中，虽然SAGA和TCC看上去可以保证数据的最终一致性，
        但分布式系统的生产环境复杂多变，某些情况是可以导致柔性事务机制失效的，
        所以无论使用那种方案，都需要最终的兜底策略，人工校验，修复数据。
```


## 3.事务的基本特征

``` 
    1.A原子性：在事务的执行过程中，要么全部执行成功，要么都不成功。
    
    2.C一致性：事务在执行前后，不能破坏数据的完整性。
              一致性更多的说的是通过AID来达到目的，数据应该符合预先的定义和约束，由应用层面来保证；
              还有的说法是C是强行为了ACID凑出来的。
              
    3.I隔离性：多个事务之间是互相隔离的，事务之间不能互相干扰，涉及到不同事务的隔离级别的问题。
    
    4.D持久性：一旦事务提交，数据库中数据的状态就应该是永久性的。
```

## 4.分布式事务介绍
### 4.1 分布式事务规范之XA
```
    1.规范流程：应用程序 -->  TM --> RM
    
    2.TM：事务管理器，即事务的协调者; 
      RM：资源管理器，可以认为是一个数据库
      
    3.XA定义了规范，2PC和3PC是XA的具体实现方式
```
![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_16164824914169.png)



### 4.2 分布式事务规范XA的实现方式之2PC
```
    1.2PC：二阶段提交(PreCommit、DoCommit)(投票阶段 + 执行阶段)
    
    2.投票阶段(PreCommit)：
       TM向所有的参与者发送prepare请求，询问是否可以执行事务，等待各个参与者的响应。
       这个阶段可以认为只是执行了事务的SQL语句，但是还没有提交。
       如果都执行成功了就返回YES，否则返回NO。
       
    3.执行阶段(DoCommit)：
       执行阶段就是真正的事务提交的阶段，但是要考虑到失败的情况。
       如果所有的参与者都返回YES，那么就执行发送commit命令，参与者收到之后执行提交事务。  
       反之，只要有任意一个参与者返回的是NO的话，就发送rollback命令，然后执行回滚的操作。
       
    4.2PC的缺陷：
       4.1 同步阻塞，可以看到，在执行事务的过程当中，所有数据库的资源都被锁定，
           如果这时候有其他人来访问这些资源，将会被阻塞，这是一个很大的性能问题。
       4.2 TM单点问题，只要一个TM，一旦TM宕机，那么整个流程无法继续完成。
       4.3 数据不一致，如果在执行阶段，参与者脑裂或者其他故障导致没有收到commit请求，
           部分提交事务，部分未提交，那么数据不一致的问题就产生了。
```

- 投票阶段(PreCommit)

![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_16164826996794.png)

- 执行阶段(DoCommit)

![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_16164827121698.png)



### 4.3 分布式事务规范XA的实现方式之3PC
```
    1.3PC：三阶段提交(CanCommit、PreCommit、DoCommit)
    
    2.CanCommit：
       这个阶段就是先询问数据库是否执行事务，发送一个canCommit的请求去询问，如果可以的话就返回YES，反之返回NO。
       
    3.PreCommit：
       这个阶段就等同于2PC的投票阶段了，发送preCommit命令，然后去执行SQL事务，成功就返回YES，反之返回NO。
       
       但是，这个地方的区别在于参与者有了超时机制，如果参与者超时未收到doCommit命令的话，将会默认去提交事务。
       
    4.DoCommit：
       DoCommit阶段对应到2PC的执行阶段，
       如果上一个阶段都是收到YES的话，那么就发送doCommit命令去提交事务，反之则会发送abort命令去中断事务的执行。
       
    5.相比2PC的改进
       5.1 对于2PC的同步阻塞的问题，我们可以看到因为3PC加入了参与者的超时机制，
           所以原来2PC的如果某个参与者故障导致的同步阻塞的问题时间缩短了，这是一个优化，但是并没有完全避免。
       5.2 第二个单点故障的问题，同样因为超时机制的引入，一定程度上也算是优化了。
       5.3 但是数据不一致的问题，这个始终没有得到解决。
```

- 3PC的CanCommit阶段：

![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_16164839086642.png)

- 3PC的PreCommit阶段：

![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_16164839182098.png)

- 3PC的DoCommit阶段：

![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_16164839289556.png)



### 4.4 分布式事务2PC的变种之TCC
```
    1.TCC：Try、Confirm、Cancel（补偿）。实际上也就是2PC的一个变种
    
    2.实现这个模式，一个事务的接口需要拆分成3个，也就是Try预占、Confirm确认提交、最后Cancel回滚
```

- TCC的简单的应用的（库存的应用）

![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_1616484355931.png)

```
具体实现：
     1.一般库存的操作，很多实现方案里面都会会在下单的时候先预占库存，
       下单成功之后再实际去扣减库存，最终如果发生了异常再回退。
       
     2.冻结、预占库存就是2PC的准备阶段，真正下单成功去扣减库存就是2PC的提交阶段，
       回滚就是某个发生异常的回滚操作，只不过在应用层面来实现了2PC的机制而已
```


### 4.5 分布式事务之SAGA（国内不常用）
```
    1.思路：将长事务拆分成多个本地短事务。如果全部执行成功，就正常完成了，反之，则会按照相反的顺序依次调用补偿。
    
    2.SAGA模式有两种恢复策略
       2.1 向前恢复，这个模式偏向于一定要成功的场景，失败则会进行重试
       2.2 向后恢复，也就是发生异常的子事务依次回滚补偿
       
    注：由于这个模式在国内基本没看见有谁用的，不多说
```

### 4.6 分布式事务之消息队列
```
    1.基于消息队列来实现最终一致性的方案(依赖MQ本身的事务消息)
    
    2.执行流程：
       2.1 业务发起方，调用远程接口，向MQ发送一条半事务消息，MQ收到消息之后会返回给生产者一个ACK
       2.2 生产者收到ACK之后，去执行事务，但是事务还没有提交。
       2.3 生产者会根据事务的执行结果来决定发送commit提交或者rollback回滚到MQ
       2.4 这一点是发生异常的情况，比如生产者宕机或者其他异常导致MQ长时间没有收到commit或者rollback的消息，这时候MQ会发起状态回查。
       2.5 MQ如果收到的是commit的话就会去投递消息，消费者正常消费消息即可。
           如果是rollback的话，则会在设置的固定时间期限内去删除消息。
```

- 分布式事务之消息队列

![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_1616484982280.png)



## 5. 分布式事务之框架（阿里）
```
    1.分布式事务之Seata(阿里开源)：TCC、XA、Saga以及AT模式的支持；
      分布式事务之GTS(阿里付费)：Global Transaction Service 全局事务服务
      
    2.组件：
       2.1 Transaction Coordinator（TC）：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。
       2.2 Transaction Manager（TM）：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。
       2.3 Resource Manager（RM）：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。
    
    3.组件间关系：
       2.1 事务开启时，TM向TC注册全局事务，并且获得全局事务XID
       2.2 这时候多个微服务的接口发生调用，XID就会传播到各个微服务中，每个微服务执行事务也会向TC注册分支事务。
       2.3 之后TM就可以管理针对每个XID的事务全局提交和回滚，RM完成分支的提交或者回滚。
```
![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_16164860501755.png)


### 5.1  AT模式(阿里原创)
```
    1.AT模式(utomatic Transaction)
    
    2.原理：原创的AT模式相比起TCC的方案来说，无需自己实现多个接口，
            通过代理数据源的形式生成更新前后的UNDO_LOG，依靠UNDO_LOG来实现回滚的操作
            
    3.执行流程：
       3.1 TM向TC注册全局事务，获得XID
       3.2 RM则会去代理JDBC数据源，生成镜像的SQL，形成UNDO_LOG，
           然后向TC注册分支事务，把数据更新和UNDO_LOG在本地事务中一起提交
       3.3 TC如果收到commit请求，则会异步去删除对应分支的UNDO_LOG，如果是rollback，就去查询对应分支的UNDO_LOG，通过UNDO_LOG来执行回滚        
```
![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_16164861296702.png)


### 5.2 TCC模式
```
    1.相比AT模式代理JDBC数据源生成UNDO_LOG来生成逆向SQL回滚的方式，TCC就更简单一点了
    
    2.流程：
       2.1 TM向TC注册全局事务，获得XID
       2.2 RM向TC注册分支事务，然后执行Try方法，同时上报Try方法执行情况
       2.3 然后如果收到TC的commit请求就执行Confirm方法，收到rollback则执行Cancel
```
![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_16164863354232.png)


### 5.3 XA模式
```
    1.执行流程：
       1.1 TM向TC注册全局事务，获得XID
       1.2 RM向TC注册分支事务，XA Start，执行SQL，XA END，XA Prepare，然后上报分支执行情况
       1.3 然后如果收到TC的commit请求就执行Confirm方法，收到rollback则执行Cancel  
```
![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_1616486420261.png)



### 5.4 SAGA模式
```
    1.流程
       1.1 TM向TC注册全局事务，获得XID
       1.2 RM向TC注册分支事务，然后执行业务方法，并且上报分支执行情况
       1.3 RM收到分支回滚，执行对应的业务回滚方法
```
![](https://gitee.com/domineering_red_tide/image/raw/master/image/企业微信截图_16164867316658.png)









