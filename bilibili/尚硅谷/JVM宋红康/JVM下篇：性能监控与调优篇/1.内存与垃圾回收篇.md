

[TOC]



# 内存与垃圾回收篇



**JVM**

![jvm](../../../../../../JVM/1.内存与垃圾回收篇/image/jvm.png)



**JVM内存结构图**

![JVM内存](../../../../../../JVM/1.内存与垃圾回收篇/image/jvm内存图.png)



## 1.JVM与JAVA体系结构

- JVM为JAVA提供一个运行环境，是JAVA程序能够跑起来。
- 高级语言会先转成机器语言，然后计算机运行。class文件二进制字节码文件其实是看不懂的，只不过IDE将class反编译转成了我们可以看懂的JAVA代码。
- 虚拟机分为系统虚拟机和程序虚拟机

  - 系统虚拟机：VMware...

  - 程序虚拟机：JAVA虚拟机...

- JAVA代码执行分类
  - 1.将JAVA源代码编译成字节码文件，然后运行时通过解释器将字节码文件转为机器码执行
  - 2.JIT编译器会将热点方法字节码class文件直接编译成机器码存放在方法区，再执行



## 2.类加载子系统

- 类加载器：引导类、扩展类、系统类（双亲委派机制）



## 3.运行时数据区

### 3.1 程序计数器

- 每个线程都有自己的程序计数器。线程私有
- **唯一一个运行时数据区没有OOM的区域**
- 作用：读取程序的执行顺序指令
- 存在的意义：CPU需要不停的切换各个线程，需要记住各个线程执行的位置



### 3.2 虚拟机栈

- 方法执行时进栈，方法执行完出栈

- 每个线程有自己的栈，栈中的数据以栈帧格式存在，每个线程上正在执行的每个方法各自对应一个栈帧。

- **栈不存在垃圾回收问题**
- -Xss 设置线程的最大栈空间。栈的大小决定了函数调用的最大可达深度
- JAVA虚拟机栈管理JAVA方法的调用，本地方法栈用于管理本地方法的调用。Hotspot JVM将本地方法栈和虚拟机栈合二为一。



### 3.3 本地方法接口

可以通过本地方法（C语言）操作操作系统。



### 3.4 堆

#### 3.4.1 堆的常见问题

- 线程共享
- 堆是GC执行垃圾回收的重点区域
- 新生代（伊甸园区 + from/to区） + 老年代 + 元空间。新生代**15次GC**就会进入老年代。
- 大对象直接分配到老年代
- -Xms 堆区的起始内存       -Xmx 堆区的最大内存     一般设置-Xms和 -Xmx一样大。超出-Xmx就会OOM。
- -Xmn 设置新生代最大内存大小
- -XX:NewRatio=2           表示新生代占1，老年代占2
- -XX:SurvivorRatio=8    表示Eden:from:to = 8:1:1
- -XX:+PrintFlagsInitial   查看所有的参数默认初始值 ， -XX:+PrintFlagsFinal  查看所有参数最终值

   

#### 3.4.2 堆GC 

Minor GC（Young GC）：新生代GC

- 会引发STW，暂停其他用户线程，等待垃圾回收结束。

Major GC（Old GC）：老年代GC

- 老年代GC后依然无法将对象保存，就会OOM。
- 老年代GC前会先尝试新生代GC。老年代GC速度比新生代GC速度慢10倍，STW时间更长

Mixed GC：新生代GC + 老年代GC

FGC：新生代GC + 老年代GC + 方法区GC

- 触发方式：①调用System.gc()    ②老年代空间不足   ③方法区空间不足
- 开发应该避免FGC



垃圾回收：频繁在新生代，很少在老年代，几乎不在元空间（方法区）。

**内存泄漏和内存溢出**：内存泄漏堆积后的后果就是内存溢出。



**逃逸分析技术**：当一个对象在方法中被定义，且该对象只在方法内部使用，则该对象没有逃逸，可以**将对象分配到栈上**。所以开发中能使用局部变量的，就不要使用在方法外定义。
JDK1.6后HotSpot默认开启逃逸分析。



**锁消除**：JIT编译器借助逃逸分析判断锁对象是否只能被一个线程访问而没有被发布到其他线程。如果没有，JIT会取消这部分的代码同步，从而提高并发性和性能。



### 3.5 方法区

- 类、运行时常量池放在方法区，创建的对象在堆中，对象的引用在栈中。

- 方法区JDK1.7之前叫永久代，JDK1.8开始叫元空间

- 方法区的垃圾回收内容：常量池中废弃的常量 + 不再使用的类

- 永久代是在虚拟机中设置内存，**元空间**则使用的是**本地内存**。

- 元空间参数设置：-XX:MetaspaceSize        -XX:MaxMetaspaceSize

- 注：JDK1.7以后静态变量 和 string常量池在堆中，之前在方法区中



**对象的实例化**

- 对象实例化方式
- 对象实例化过程
- 对象内存布局：对象头、实例数据...
- 访问对象的方式
  - 方式1：句柄访问
  - 方式2：直接指针（Hotspot采用）



### 3.6 直接内存

- 直接内存是指直接使用本地内存，访问直接内存速度优于JAVA堆，读写性能高。

- 读写频繁的场景会考虑使用直接内存，JAVA的NIO库允许JAVA程序使用直接内存，用于数据缓冲区。

- 使用JAVA堆内存，IO会将数据从用户态切换到内核态，再与磁盘交互，内存需要2份重复数据；而NIO直接使用本地内存，直接用的就是内核态，数据缓存在本地内存中。

- 直接内存分配回收不受JVM内存回收管理

- MaxDirectMemorySize 设置直接内存，不设置则默认与堆的最大值-Xmx值一致



### 3.7 执行引擎

- JVM负责装载class字节码到其内部，不能直接运行再操作系统之上；

- 执行引擎负责将class字节码解释为对应平台上的本地机器指令，简而言之就是将高级语言翻译为机器语言



**JAVA为什么是半编译半解释语言？**
解释器：将class字节码逐行解释为本地机器指令执行命令
JIT编译器：将热点class字节码编译成机器码放到方法区缓存

注：解释器可以让class文件直接执行；编译器可以编译代码，遇到代码可以直接使用编译后的机器语言直接执行，效率比用解释器直接执行class快。



解释器优点是可以直接运行代码，但是运行速度相对编译慢；编译方式是需要先编译才能运行，但是编译后是机器语言，运行速度比直接解释速度快。**HotSpot VM：解释器 + JIT即时编译器。HotSpot虚拟机执行的JAVA服务启动时先用的解释器执行，省去了编译时间，随着时间推移，根据热点探测功能，将有价值的字节码编译成本地机器码提高程序执行效率。**热点代码可能只是一个经常被调用的方法。热点代码被JIT编译成机器码的调用阈值Server模式下是一定时间下10000次，如果热度下降，计数也会降低。阈值设置参数 -XX:CompileThreshold。



**机器码、指令、指令集、汇编语言、高级语言**

- 机器码：0和1的二进制编码。也叫机器指令码。
- 指令：将机器码特定的0和1简化成对应的指令，例如：mov、inc...
- 指令集：不同硬件平台支持的指令不一致。平台所支持的一系列指令叫指令集。
- 汇编语言：汇编语言是用助记符替代机器指令。计算机不能识别汇编语言，汇编语言需要翻译成机器指令计算机才能识别。此外汇编语言可以优化代码，所以高级语言会先编译成汇编语言。
- 高级语言：需要将高级语言解释或编译成机器指令才能在计算机上运行。



### 3.8 StringTable**（需要看视频理解下）**

- 8种基本类型的常量池在方法区中；**String常量池** 和 **静态变量** 1.6及之前在方法区，1.7之后在堆中

- 直接给String赋值，是在字符串常量池中

- String Pool是一个固定的Hashtable。如果String放入过多，hash冲突变多，链表变长，取值会慢。





## 4.垃圾回收

- 垃圾：运行程序中没有任何指针指向的对象，这个对象需要被垃圾回收

- GC的作用区域：堆（新生代 + 老年代） +  方法区。频繁GC年生代、较少GC老年代、基本不GC方法区。
- 垃圾回收算法
  - 1.标记-清除算法：清除垃圾后内存不连续。老年代使用。
  - 2.复制算法：from/to区采用复制算法。效率最高，单浪费一倍的内存。
  - 3.标记-整理算法：标记-清除 + 碎片整理。老年代使用。比"复制算法"多了一个标记，比"标记-清除"多了一个内存整理。

- 并发和并行
  - 并发：一个CPU核在多个线程间切换，因为CPU速度很快，外界感觉不到切换，以为是线程并行。
  - 并行：多个CPU核自己处理自己的线程。

- JAVA引用类型
  - 1.强引用：99%以上都是强引用。
  - 2.软引用：高速缓存
  - 3.弱引用：高速缓存
  - 4.虚引用：跟踪垃圾回收过程，在对象被回收的时候接到一个系统通知

- GC性能评价指标

  - 1.吞吐量：吞吐量 = 用户代码运行时间 / （用户代码运行时间 + GC时间）
  - 2.暂停时间：GC时工作线程被暂停的时间
  - 注：吞吐量 和 暂停时间是冲突的，一般是在最大吞吐量优先的情况下，降低停顿时间。

- 垃圾收集器

  - 串行回收器：Serial（复制）、Serial Old（标记-整理）
  - 并行回收器：ParNew（复制）、Parallel Scavenge（复制）、Parallel Old（标记-整理）
  - 并发回收器：CMS（标记清除。JAVA9已删除）
  - 并发、并行回收器：G1（复制算法 + 标记-整理）

  注：串行回收器是单CPU核进行垃圾回收；并行回收器是多CPU核进行垃圾回收，垃圾回收效率比串行快；并发回收器是CPU核垃圾回收和用户线程间告诉切换，不会完全STW，从而达到提供低延迟服务的效果。

- GC参数设置

  - -XX:+UseSerialGC           使用Serial + Serial Old垃圾回收器
  - -XX:+UseParNewGC       年轻代使用ParNew垃圾回收器
  - -XX:+UseParallelGC        默认激活Parallel Scavenge + Parallel Old 
  - -XX:+UseParallelOldGC  默认激活Parallel Scavenge + Parallel Old 
  - -XX:+UseConcMarkSweepGC     默认激活ParNew + CMS   
  - -XX:+UseG1GC                新生代 + 老年代（JDK9默认的垃圾回收器）

- 常见垃圾收集器的组合选择

  - Serial + Serial Old                             最小化使用内存和并行开销
  - Serial + CMS                                      CMS可以最小化GC的中断和停顿时间
  - Parallel Scavenge + Parallel Old     最大化应用程序吞吐量。JAVA8默认使用该组合
  - G1                                                       新生代 + 老年代。JDK9默认的垃圾回收器

- G1的JVM性能优化
  - 1.开启G1垃圾回收器           -XX:+UseG1GC 
  - 2.设置堆的最大内存            -Xms 堆区的起始内存       -Xmx 堆区的最大内存 
  - 3.设置最大的停顿时间        -XX:MaxGCPauseMillis    期望最大GC停顿时间（默认值200ms）

- 
  怎么选择垃圾回收器？

  - 优先让JVM自适应，调整堆的大小
  - 串行收集器：内存小于100M；单核、单机程序，并且没有停顿时间的要求
  - 并行收集器：多CPU、高吞吐量、允许停顿时间超过1秒
  - 并发收集器：多CPU、追求低停顿时间、快速响应（比如延迟不能超过1秒，如互联网应用）
  - 官方推荐G1，性能高。现在互联网的项目，基本都是使用G1



**可达性分析算法**分析对象是否有引用，需要被回收，这就导致会造成GC时产生"STW(Stop The World)"。垃圾回收时会发生STW，应用程序所有线程都会被挂起。



**内存泄漏**：1.资源未关闭close   2.ThreadLocal未调用remove()方法



**垃圾收集器**

![GC分类](../../../../../../JVM/1.内存与垃圾回收篇/image/GC分类.png)











**指针碰撞**：堆内存GC后会整理出连续内存空间，内存前面是连续空间放的对象，后面是空内存位置，指针此时在前后空间的中间位置，用来标记隔离堆内存是否可用，再放对象时，对象放入整理使用连续内存并将标记指针移动到新的位置，用来标记指针前面已经存对象，后面是可用堆内存还未被使用。**指针碰撞说白了就是标记内存使用和未使用的分界线，以放新的对象而不至于放入对象冲突。**





**GC日志分析**

![](../../../../../../JVM/1.内存与垃圾回收篇/image/GC日志1.png)

![](../../../../../../JVM/1.内存与垃圾回收篇/image/GC日志2.png)

![](../../../../../../JVM/1.内存与垃圾回收篇/image/GC日志3.png)

















