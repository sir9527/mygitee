

* 1.为什么要调优
* 2.调优的大方向
* 3.性能优化的步骤
* 4.性能评价
	* 4.1 接口响应时间
	* 4.2 垃圾回收之暂停时间
	* 4.3 垃圾回收之吞吐量
	* 4.4 并发数
	* 4.5 内存占用
	* 注：吞吐量、并发数、响应时间间关系



# 1.概述篇

## 1. 为什么要调优

- 防止出现OOM

- 解决OOM

- 减少Full GC出现的频率



## 2. 调优的大方向

- 合理地编写代码

- 充分并合理的使用硬件资源

- 合理地进行JVM调优



## 3. 性能优化的步骤

### 第1步(发现问题)：性能监控

- GC频繁

- cpu load过高

- OOM

- 内存泄露

- 死锁

- 程序响应时间较长
- ...

  

### 第2步(排查问题)：性能分析

- 打印GC日志，通过GCviewer或者 http://gceasy.io 来分析异常信息

- 灵活运用命令行工具、jstack、jmap、jinfo等

- dump出堆文件，使用内存分析工具分析文件

- 使用阿里Arthas、jconsole、JVisualVM来实时查看JVM状态

- jstack查看堆栈信息
- ...



### 第3步(解决问题)：性能调优

- 适当增加内存，根据业务背景选择垃圾回收器

- 优化代码，控制内存使用

- 增加机器，分散节点压力

- 合理设置线程池线程数量

- 使用中间件提高程序效率，比如缓存、消息队列等

- 其他……



## 4. 性能评价

### 4.1 接口响应时间
提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。




### 4.2 垃圾回收之暂停时间

暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。

-XX:MaxGCPauseMillis：最大暂停时间



### 4.3 垃圾回收之吞吐量

定义：对单位时间内完成的工作量（请求）的量度

参数XX::GCTimeRatio=n

举个官方的例子，参数设置为19，那么GC最大花费时间的比率=1/(1+19)=5%，程序每运行100分钟，允许GC停顿共5分钟，其吞吐量=1-GC最大花费时间比率=95%

默认情况下，VM设置此值为99，运行用户代码时间是GC停顿时间的99倍，即GC最大花费时间比率为1%




### 4.4 并发数

定义：同一时刻，对服务器有实际交互的请求数

例如1000人同时在线，并发数5%，也就是说并发量是50



### 4.5 内存占用

JAVA堆区所占的内存大小



**吞吐量、并发数、响应时间间关系**

响应时间：车速

吞吐量：每天高速公路收费站通过的车辆的数据

并发数：高速公路上正在行驶的车辆的数量



**三者间关系**

- 并发数少，车速高，吞吐量小；
- 并发数中，车速慢，吞吐量高；
- 并发数高，车速为0，吞吐量为0（服务器资源耗尽）

